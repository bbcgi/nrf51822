#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "nrf.h"
#include "nrf_gpio.h"
#include "nrf_delay.h"
#include "nrf51_bitfields.h"
#include "packet_def.h"
#include "myUTILITY.h"
#include "sha256.h"

void loadSHAFromFlash( uint8_t  * volatile hash ){
		uint32_t addr = (uint32_t)0x02A002 ; 
	
	  memcpy( hash , (uint8_t*)addr , 32 ) ; 
}

//=====
//
//
//===============
void get_byte_hex( uint8_t b, uint8_t *_ascii ){
		uint8_t nybble_chars[] = "0123456789ABCDEF";
	
	
		_ascii[1] = nybble_chars[ ( b >> 4 ) & 0x0F ]; 
		_ascii[0] = nybble_chars[ b & 0x0F ];
}

void myPrintHEX( uint8_t const* buff ,uint16_t len ){
		uint16_t i ; 
		uint8_t		_asc[2] ; 
	
		for(i=0;i<len;i++){
				get_byte_hex( buff[i], _asc );
				uart_put('0') ;
				uart_put('x') ;
				uart_put(_asc[1]) ;
				uart_put(_asc[0]) ;
				uart_put(',') ;
				if( i % 10 == 0 )
				{
						uart_put('\r') ;
						uart_put('\n') ;	
				}
		}
		
	
				uart_put('\r') ;
		uart_put('\n') ;
}

void  my_uint16_to_a(uint16_t num , uint8_t* b){
    uint8_t const digit[] = "0123456789";
    uint8_t* p = b;
   
    int32_t shifter = (int32_t)num;
	
		
	
    do{ //Move to where representation ends
        ++p;
        shifter = (int32_t)(shifter/10) ;
    }while(shifter);
    *p = '\0';
    do{ //Move back, inserting digits as u go
        *--p = digit[num%10];
        num = (int32_t)(num/10);
    }while(num);
   
}

void saveDefaultPWD(void){
	uint32_t  _addr = (uint32_t)FLASH_SUPER_PWD_ADDR ; 
	uint16_t* p_ptr = (uint16_t*)_addr ; 
	uint16_t  u16HASH[17] ; 
	uint8_t		defaultPwd[4] = {1,2,3,4} ; 
	SHA256_CTX  shaCTX ; 

	if( *p_ptr == DIRTY ){
		return ; 
	}
	else{
		u16HASH[0] = DIRTY ; 
		tyttSHA256(&shaCTX , defaultPwd ,(uint8_t*)&u16HASH[1]) ;

		my_nvmc_write_words((uint32_t)FLASH_SUPER_PWD_ADDR, (uint32_t *)u16HASH, 10 ) ; 
		nrf_delay_ms(10) ;
	}
}
void my_print_coord( uint16_t iX , uint16_t iY ){
		uint8_t		xx[10] ;
		uint8_t		yy[10] ; 
	
	
		my_uint16_to_a( iX , xx ) ; 
		my_uint16_to_a( iY , yy ) ; 
		uart_put('\r');
		uart_put('\n');
		uart_put('<');
		uart_putstring(xx) ;
		uart_put(',') ; 
		uart_putstring(yy) ;
		uart_put('>');
		

}

//=================
//	void mySRAND( int32_t* pSEED )
//  [function]:generate seed for randon keyboard usage
//  					all the function (only once)when boot up
//	[Parameters]
//			[out]		pSEED as seed
//   
//==================

void mySRAND( void ){

	  NRF_RNG->EVENTS_VALRDY = 0;
    NRF_RNG->TASKS_START = 1 ; 
    while (NRF_RNG->EVENTS_VALRDY == 0) ;
		NRF_RNG->VALUE ; 
    
		srand(NRF_RNG->VALUE) ; 
	
		NRF_RNG->TASKS_STOP = 1 ; 
	
	
}


//======================================
//  int32_t myRAND( int32_t* seed )
//  [function]: comput uniform distibution random number
//  [Parameters] 
//          [in]seed: pointer of int32_t generated by randomNUMBER()
//
//  [Returns] number
//================================================
int32_t myRAND( int32_t* seed )
{
    uint64_t tmp ; 
    
    tmp =( *seed * 11035152245 ) +12345 ; 
	
		
    *seed = (int32_t)tmp ; 
	
		if(*(seed) < 0) 
			(*seed) = -1*(*seed) ; 
		
    return *seed ;      
}

bool  my_strncmp(uint8_t* s1, uint8_t* s2 , uint8_t n)
{   
  
    uint8_t i ; 
    
    for(i=0;i<n;i++ ){
        if( s1[i] < s2[i] ) 
            return false ;
        else if( s1[i] > s2[i] )
            return false ; 
    }
    
    
    return true ; 

}








//=========================
//  void  myitoa(uint8_t num , uint8_t* b)
//  [function]:convert uint8_t number to ascii for print
//	[Parameters]
//						[in] num
//						[out] uint8_t array 
//==================================

void  myitoa(uint8_t num , uint8_t* b){
    uint8_t const digit[] = "0123456789";
    uint8_t* p = b;
   
    int16_t shifter = (int16_t)num;
    do{ //Move to where representation ends
        ++p;
        shifter = shifter/10;
    }while(shifter);
    *p = '\0';
    do{ //Move back, inserting digits as u go
        *--p = digit[num%10];
        num = num/10;
    }while(num);
   
}


uint32_t myAsciitoInt( uint8_t* arr){
    uint8_t* ptr = arr ; 
    uint32_t  _num = 0x00 ; 
    
    while( *(ptr+1) != 0x00 ){
        uint8_t tmp = *ptr ;  
        _num += (uint32_t)(tmp-0x30) ; 
        _num *= (uint32_t)10 ;
        tmp = 0 ; 
        ptr++ ; 
    }
    
    _num += (uint32_t)(*ptr-0x30) ; 
    
    return _num ; 
}


void ch2ASCII( uint8_t const*  kb , uint8_t* buff ,uint8_t length){
    uint8_t i ; 
    
    for( i=0;i<length;i++ ){
        if( kb[i] < 0x0A ){
            buff[i] = kb[i]+0x30 ; 
        }
        else{
            buff[i] = kb[i]+0x37 ; 
        }
    }        
   
}




void my_nvmc_write_words(uint32_t address,  uint32_t const* src, uint32_t num_words)
{
  uint32_t i;

  // Enable write.
  NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Wen;
  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
  {
  }

  for(i=0;i<num_words;i++)
  {
    ((uint32_t*)address)[i] = src[i];
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy);
    
  }

  NRF_NVMC->CONFIG = NVMC_CONFIG_WEN_Ren;
  while (NRF_NVMC->READY == NVMC_READY_READY_Busy)
  {
  }
}


